package handlers

import (
    {{- range .Imports }}
    "{{ . }}"
    {{- end }}
)

type I{{ .Handler.Name }} interface {
    {{- range .Handler.Routes }}
    {{ .Method }}(c *gin.Context)
    {{- end }}
}

type {{ .Handler.Name }} struct {
    Service *services.{{ .Service.Name }}
}

func New{{ .Handler.Name }}(service *services.{{ .Service.Name }}) *{{ .Handler.Name }} {
    return &{{ .Handler.Name }}{
        Service: service,
    }
}

{{- range .Handler.Routes }}

func (h *{{ $.Handler.Name }}) {{ .Method }}(c *gin.Context) {
    {{- if .RequestModel }}
    // Extract request data
    var req models.{{ .RequestModel }}
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    {{- end }}

    // Call service method
    {{- if .Method }}
    {{- if .ResponseModel }}
    res, err := h.Service.{{ .Method }}(c.Request.Context(), {{ if .RequestModel }}&req{{ end }})
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"resp": &models.{{ .ResponseModel }}{}})
    {{- else }}
    err := h.Service.{{ .Method }}(c.Request.Context(), {{ if .RequestModel }}&req{{ end }})
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.Status(http.StatusOK)
    {{- end }}
    {{- else }}
    // Service method not specified
    c.JSON(http.StatusNotImplemented, gin.H{"error": "Service method not implemented"})
    {{- end }}
}

{{- end }}
